# GitLab CI/CD pipeline for Django and Vue application
---
# Stages: build -> test -> deploy
# Release MRs run the full pipeline including Terraform and image push

workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: always
    - if: '$CI_PIPELINE_SOURCE == "push"'
      when: always
    - if: '$CI_PIPELINE_SOURCE == "tag"'
      when: always
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: always
    - when: never

# Docker-in-Docker runner using rootless mode
default:
  image: docker:20.10
  services:
    - name: docker:20.10-dind-rootless
      alias: docker
  variables:
    DOCKER_HOST: unix:///run/user/1000/docker.sock
    DOCKER_TLS_CERTDIR: ""
    DOCKER_BUILDKIT: "1"
    MASK_SECRETS: "true"
    TFSEC_VERSION: "1.28.1"
  before_script: []
  cache:
    key: "$CI_PROJECT_ID-$CI_JOB_NAME-$CI_COMMIT_REF_SLUG"
    policy: pull-push
    paths:
      - .cache/pip
      - .npm

stages:
  - build
  - test
  - deploy

# ---- Build stage ----

# Build base images for all stages
# NOTE: Ideally these images should be produced with buildx in a single command
# to avoid redundant parsing. This sample keeps separate commands for clarity.
build_base_images:
  stage: build
  script:
    - docker pull myapp-build:latest || true
    - docker pull myapp-sast-node:latest || true
    - docker pull myapp-sast-python:latest || true
    - docker pull myapp-test:latest || true
    - docker pull myapp-test-runtime:latest || true
    - |
      docker build --build-arg TARGET_ENV=${CI_COMMIT_REF_NAME} --target build --cache-from=myapp-build:latest -t myapp-build:${CI_COMMIT_SHA} .
      docker build --build-arg TARGET_ENV=${CI_COMMIT_REF_NAME} --target sast-node --cache-from=myapp-sast-node:latest -t myapp-sast-node:${CI_COMMIT_SHA} .
      docker build --build-arg TARGET_ENV=${CI_COMMIT_REF_NAME} --build-arg TFSEC_VERSION=${TFSEC_VERSION} --target sast-python --cache-from=myapp-sast-python:latest -t myapp-sast-python:${CI_COMMIT_SHA} .
      docker build --build-arg TARGET_ENV=${CI_COMMIT_REF_NAME} --target test --cache-from=myapp-test:latest -t myapp-test:${CI_COMMIT_SHA} .
      docker build --build-arg TARGET_ENV=${CI_COMMIT_REF_NAME} --target test-runtime --cache-from=myapp-test-runtime:latest -t myapp-test-runtime:${CI_COMMIT_SHA} .
      docker build --build-arg TARGET_ENV=${CI_COMMIT_REF_NAME} --target runtime -t myapp:${CI_COMMIT_SHA} .
  rules:
    - if: '$CI_COMMIT_REF_NAME =~ "^(feature|develop|release)$"'

# ---- Test stage ----
front_sast:
  stage: test
  script:
    - docker run --rm myapp-sast-node:${CI_COMMIT_SHA} sh -c 'cd /app/frontend 2>/dev/null || cd /app && eslint . -f sarif -o eslint.sarif'
  rules:
    - if: '$CI_COMMIT_REF_NAME =~ "^(feature|develop|release)$"'
  needs:
    - build_base_images
  artifacts:
    reports:
      sast: eslint.sarif
    expire_in: 1 week

backend_sast:
  stage: test
  script:
    - docker run --rm myapp-sast-python:${CI_COMMIT_SHA} sh -c 'ruff . --output-format sarif > ruff.sarif'
  rules:
    - if: '$CI_COMMIT_REF_NAME =~ "^(feature|develop|release)$"'
  needs:
    - build_base_images
  artifacts:
    reports:
      sast: ruff.sarif
    expire_in: 1 week

tf_sast:
  stage: test
  script:
    - docker run --rm myapp-sast-python:${CI_COMMIT_SHA} sh -c 'tfsec /app/terraform --format sarif > tfsec.sarif'
  rules:
    - if: '$CI_COMMIT_REF_NAME == "release"'
  needs:
    - build_base_images
  artifacts:
    reports:
      sast: tfsec.sarif
    expire_in: 1 week

unit_tests:
  stage: test
  script:
    - docker run --rm myapp-test:${CI_COMMIT_SHA} pytest --junitxml=junit.xml tests/unit
  rules:
    - if: '$CI_COMMIT_REF_NAME =~ "^(develop|release)$"'
  needs:
    - build_base_images
  artifacts:
    reports:
      junit: junit.xml
    expire_in: 1 week

functional_tests:
  stage: test
  script:
    - docker run -d --name django_app --network host myapp-test-runtime:${CI_COMMIT_SHA}
    - docker exec django_app pytest tests/functional
    - docker stop django_app
  rules:
    - if: '$CI_COMMIT_REF_NAME == "release"'
  needs:
    - unit_tests

# ---- Deploy stage ----
terraform_init:
  stage: deploy
  image: hashicorp/terraform:1.5.6
  tags: [terraform]
  script:
    - terraform init
  rules:
    - if: '$CI_COMMIT_REF_NAME == "release"'
  when: on_success
  variables:
    AWS_REGION: $AWS_REGION
  secrets:
    AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID
    AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY

terraform_plan:
  stage: deploy
  image: hashicorp/terraform:1.5.6
  tags: [terraform]
  script:
    - terraform plan -out=tfplan
  rules:
    - if: '$CI_COMMIT_REF_NAME == "release"'
  needs:
    - terraform_init
  when: on_success
  variables:
    AWS_REGION: $AWS_REGION
  secrets:
    AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID
    AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY

terraform_apply:
  stage: deploy
  image: hashicorp/terraform:1.5.6
  tags: [terraform]
  script:
    - terraform apply -auto-approve tfplan
  rules:
    - if: '$CI_COMMIT_REF_NAME == "release"'
  needs:
    - terraform_plan
  when: on_success
  variables:
    AWS_REGION: $AWS_REGION
  secrets:
    AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID
    AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY

dev_deploy:
  stage: deploy
  script:
    - docker tag myapp:${CI_COMMIT_SHA} myapp:dev-${CI_COMMIT_SHORT_SHA}
    - echo "Deploying container to EC2 filesystem"
  rules:
    - if: '$CI_COMMIT_REF_NAME == "develop"'
  needs:
    - functional_tests

build_image:
  stage: deploy
  script:
    - |
      DATE_TAG=$(date +%Y%m%d.%H%M)-${CI_COMMIT_SHORT_SHA}
      docker tag myapp:${CI_COMMIT_SHA} myapp:${DATE_TAG}
      echo $DATE_TAG > image_tag.txt
  rules:
    - if: '$CI_COMMIT_REF_NAME == "release"'
  needs:
    - terraform_apply
  artifacts:
    paths:
      - image_tag.txt

push_image:
  stage: deploy
  image: amazon/aws-cli:latest
  script:
    - set +x
    - aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin --quiet $AWS_ECR_ACCOUNT_URL
    - set -x
    - DATE_TAG=$(cat image_tag.txt)
    - docker tag myapp:${DATE_TAG} $AWS_ECR_ACCOUNT_URL/myapp:${DATE_TAG}
    - docker push $AWS_ECR_ACCOUNT_URL/myapp:${DATE_TAG}
  rules:
    - if: '$CI_COMMIT_REF_NAME == "release"'
  needs:
    - build_image
  variables:
    MASK_SECRETS: 'true'
  secrets:
    AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID
    AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY
